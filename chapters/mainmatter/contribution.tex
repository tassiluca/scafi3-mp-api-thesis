% !TeX root = ../../main.tex
\chapter{Contribution}

In this chapter is presented the conceptualization of a proposed Scala-based reference architecture for enabling the development of cross-platform, polyglot and distributed libraries and frameworks.

Its discussion is structured as follows.
%
First, the intents and application scenarios motivating the proposed architecture are discussed.
%
Subsequently, the corresponding requirements and constraints are formalized.
%
Thereafter, the elements composing the architecture are presented.
%
Finally, the implications of adopting this design are analyzed.

\section{Intents}

The intents of the proposed architecture are to enable the development of distributed Scala libraries and frameworks to be both \textit{cross-platform}, that is, able to run on multiple platforms and runtimes; and \textit{polyglot}, that is, designed to be able to interoperate with its public interface from multiple programming languages.
%
Both intents are achieved while maintaining a unified version of the components implementing the application logic of the software product.

\section{Application scenarios}

This architecture is well suited when the following scenarios arise:

\begin{itemize}
    \item \textbf{Application environment heterogeneity.} The library or framework implements functionalities that should be deployed and executed in heterogeneous environments, spanning across multiple platforms and runtimes. This may arise from the heterogeneity of end-user deployment environments or the requirement that platform and runtime selection remain contingent upon the specific application context in which the library is used.
    \item \textbf{Polyglot end-user base.} The library is designed for developers working across different programming languages, enabling team diversity, facilitating integration with existing codebases in various languages, and leveraging language-specific features and ecosystems.
    \item \textbf{Unified application logic.} The library exposes its functionalities through a unified API, regardless of the target platform, runtime or programming language. This ensures behavioral consistency across all supported environments, enabling seamless interoperability between programs utilizing the library, regardless of their target platform or implementation language.
\end{itemize}

\section{Requirements}

Requirements formally describe the boundary of applicability of the proposed architecture.
%
These can be categorized into \textit{user}, \textit{system} and \textit{implementation} requirements and address two types of stakeholders: \textit{library users}, who are developers intending to use the libraries and frameworks designed following the proposed architecture; and \textit{library developers}, who design and implement such libraries and frameworks.

\subsubsection{User requirements}

\begin{enumerate}[label=U\arabic*.]
    \item Library users must be able to interact with the library from multiple programming languages through a consistent API that leverages its functionalities and benefits from language-specific ecosystem features. Supported languages include:
    %
    \begin{itemize}
        \item Scala;
% todo: \item Java;
        \item JavaScript; 
        \item TypeScript;
        \item C and C++.
    \end{itemize}
    %
    \item The library must support execution across heterogeneous platforms and runtimes to accommodate diverse Library User deployment environments. Library users must be able to implement their own solution by building upon the library's core functionalities:
    %
    \begin{itemize}
        \item using Scala, with deployments possibly spanning across multiple platforms and runtimes:
        \begin{itemize}
            \item JVM;
            \item JavaScript environments, both browser-based and server-side (Node.js);
            \item Native environments, including desktop, server, and System on Chip (SoC) devices running on 64-bit and ARM architectures.
        \end{itemize}
        \item using other supported languages, targeting their respective platforms. Except for Scala, Library Users should not need to compile code written for one platform to run on another; e.g., compiling C code to run on Node.js.
    \end{itemize}
    \item Library users can distribute the execution of their application-specific code across multiple machines, with each node potentially running on different platforms, runtimes, and programming languages. The library provides distributed communication mechanisms that enable seamless interoperability and coordination among heterogeneous nodes.
\end{enumerate}

\subsubsection{System requirements}

\begin{enumerate}[label=S\arabic*.]
    \item Library developers must be able to implement the library logic once reuse it across all supported platforms and runtimes. Modifications to the library logic are automatically reflected across all target platforms and runtimes.
    \item Library API must be consistent across all supported languages and behaves uniformly regardless of the target platform, runtime and programming language.
\end{enumerate}

\subsubsection{Implementation requirements}

\begin{enumerate}[label=I\arabic*.]
    \item Developers implement the library taking advantage of the full Scala language features and capabilities, enabling them to harness functional programming, type-safe abstractions, expressive syntax and compositional design patterns to facilitate the development of robust, scalable and distributed software systems.
    \item The bridge layer between programming languages should not rely on remote procedure calls (RPC) or inter-process communication (IPC) mechanisms to not incur in the performance penalties associated with these techniques.
\end{enumerate}

\section{Constraints}

The proposed architecture imposes a fundamental constraint that significantly influences architectural decisions: all dependencies must support cross-compilation to all target platforms.
%
Where such multi-platform support is unavailable, platform-specific implementations must be provided explicitly to bridge the abstraction gap.
%
If an existing Scala library heavily relies on platform-specific dependency or its design is tightly coupled with a specific platform or runtime, adapting it to the proposed architecture may prove impractical or require substantial reengineering efforts.

For example, a distributed Scala library built on Akka\footnote{\url{https://akka.io}} and utilizing its remoting, and clustering capabilities would require substantial redesign to support multi-platform execution, as Akka targets only the JVM, unless these dependencies have been carefully abstracted as replaceable components.
%
Furthermore, when platform-specific dependencies provide critical non-functional properties---such as fault tolerance or scalability---that multi-platform alternatives cannot yet match, adapting to a cross-platform architecture becomes not merely impractical but potentially unfeasible.
%
In these cases, the tight coupling to a specific platform represents an architectural constraint rather than an implementation detail, and the proposed architecture may not constitute a suitable approach for such libraries without fundamentally revisiting their core design principles.

\section{Architectural elements}

The proposed architecture, presented in \Cref{fig:reference-architecture}, is composed of three main components:

\begin{enumerate}
    \item a \textbf{pure core module}, implementing the application logic of the library. This module is designed to be platform-agnostic and independent of any specific technology or runtime;
    \item a \textbf{cross-platform infrastructure module}, responsible for enabling the distribution of the library functionalities across multiple end nodes. This includes a \textbf{general cross-platform and polyglot serialization binding}, providing the capability to marshal and unmarshal data structures exchanged between different platforms, runtimes and programming languages;
    \item a \textbf{polyglot abstraction layer}, exposing a simplified and consistent interface API to library users through different programming languages.
\end{enumerate}

The core module and the cross-platform infrastructure module together constitute the \textit{Software Product}, which implements the library's core functionalities and delivers its primary value.
%
The polyglot abstraction layer, by contrast, forms part of the \textit{User Interface}, providing the programmatic interface through which library users interact with the software product using any of the supported programming languages.
%
This separation enables library users to interact seamlessly with the library in their preferred programming language, accessing its functionalities through native packages generated by the polyglot library abstraction layer.
%
Library developers, meanwhile, can focus on implementing the core logic without being concerned about language-specific details.

\begin{figure}
    \centering
    \includegraphics[width=\textwidth]{resources/img/architecture.pdf}
    \caption{Proposed reference architecture for cross-platform, polyglot and distributed Scala libraries and frameworks.}
    \label{fig:reference-architecture}
\end{figure}

\subsection*{Pure library core module}

The core module is the heart of the library, implementing its core application logic and functionalities in terms of domain modeling, business rules and application use cases.
%
Its architecture is deliberately designed to be both platform- and technology-agnostic, ensuring the core logic to be reusable across multiple execution environments without requiring any modification or adaptation.
%
This design can be achieved by adhering to the Hexagonal (Ports \& Adapters) Architectural pattern \cite{hexagonal}, which promote the decoupling of the core logic from external dependencies by defining clear interfaces (ports) and isolating the core logic from infrastructural concerns (adapters).

Implemented as a Scala pure multi-platform module, it enables the cross-compilation of the core logic to all target platforms and supported runtimes.

\subsection*{Cross-platform infrastructure module}

This is the component dealing with infrastructural concerns.
%
Despite the fact it is conceptually represented as a single module, depending on the complexity of the library and its requirements, it can be decomposed into multiple modules, each addressing specific infrastructural aspects.
%
Its core responsibilities include the implementation of a distributed communication mechanism and a general serialization binding.

\subsubsection*{Cross-platform distribution module}

Concerning the distributed communication mechanism, the library may leverage different underlying technologies, protocols and styles depending on the specific use case and requirements, such as peer-to-peer or publisher-subscriber models.
%
Regardless of the chosen model, the design must maximize code sharing across all supported platforms and runtimes. 
%
This is achieved through well-defined Platform Interfaces that interact with platform-specific adapters, which encapsulate only the minimal necessary platform-dependent code.
%
Whenever possible, existing multi-platform libraries and frameworks should be leveraged to minimize platform-specific code.
%
Conversely, when no suitable multi-platform library exists, custom platform-specific implementations must be developed by interacting directly with the underlying platform capabilities and ecosystem via Scala Native or Scala.js interoperability features.
%
In both cases, all implementation adapters must conform to the defined Platform Interfaces to ensure maintainability and facilitate the integration of alternative platform-specific implementations.

\subsubsection*{Polyglot serialization binding}

Regarding the serialization binding, it must be designed to be format-agnostic and interoperable across different programming languages and platforms.
%
While the first it's a desideratum to ensure flexibility and interchangeability of serialization formats, the latter is a strict requirement.
%
Indeed, if the serialization format is not compatible across all supported languages and platforms, the library would not be able to consistently exchange messages between different end nodes, thus undermining its distributed nature.

The selection of a serialization format requires careful consideration of multiple factors.
%
Performance and efficiency trade-offs between textual and binary formats must be evaluated alongside compatibility with all supported programming languages and platforms.
%
Additionally, the choice between schema-based and schema-less formats affects flexibility and evolution capabilities of the serialized data structures.
%
A critical consideration is the degree of automation in serializer and deserializer generation: while automatic code generation simplifies development, it may constrain the ability to define custom data types and structures that leverage language-specific abstractions.
%
This tension is particularly relevant given that different programming languages offer distinct type systems and abstractions that cannot always be straightforwardly mapped across platforms.

\subsection*{Polyglot library abstraction layer}

The polyglot abstraction layer exposes a uniform interface enabling cross-language interaction with the library's core functionalities. 
%
Two critical challenges converge to demand the presence of this layer: type system mismatches and limited type construct mapping.

\vspace{0.5em}
\noindent
\textbf{Type system mismatches.}
%
Mismatches arise because both Scala Native and Scala.js address language semantics differences by reifying them into new types.
%
For example, Scala.js introduce the \texttt{js.Map} type to represent JavaScript maps, distinct from Scala's native \texttt{Map} type.
%
Similarly, both projects represent lambda functions or nullable types using specific types: \texttt{js.UndefOr} in Scala.js and \texttt{null} in Scala Native for nullable types or \texttt{js.FunctionN} for JavaScript lambdas and \texttt{CFuncPtrN} for C function pointers.
%
While this approach preserve type-safety, guarantees correct usage, and ensures users to be aware of the underlying platform constraints and peculiarities, it prevents exposing a unified API across all supported languages.
%
Without this layer, library developers would be forced to create different facades for both JavaScript and C, leading to code duplication, increased maintenance effort and potential inconsistencies.

\vspace{0.5em}
\noindent
\textbf{Limited type construct mapping.}
%
This is a consequence of the fact that only a subset of Scala type constructs can be mapped and exposed to JavaScript and C.
%
Indeed, while Scala code can be cross-compiled to both JavaScript and native binaries, not all Scala type constructs have a direct counterpart in these target languages.
%
Consequently, the ability to cross-compile a Scala construct does not guarantee it can be exposed to or utilized by other programming languages.
%
For example, Scala's rich type system includes Path Dependent Types and Implicit parameters, which have no direct equivalents in other programming languages.

The proposed polyglot abstraction layer tackles these challenges by introducing \textit{abstract, language-independent types} that are \textit{isomorphic} to their Scala counterparts: although being abstract and decoupled from any specific programming language or platform, they can be mapped one-to-one to some corresponding Scala type.
%
These types, referred to as \textbf{Portable Types}, are then instantiated within each supported platform and language, providing language-specific implementations and dedicated bidirectional conversion between language-specific types and their corresponding Scala equivalents.

Using this approach the core library API is exposed to library users through portable types, providing simplified interfaces as a thin wrapper around the core library API, internally handling the conversion between portable types and the corresponding Scala types with which the core library operates.
%
These interfaces---referred to as \textbf{Portable Libraries}---can then be exported, packed and distributed as native packages for each supported programming language since, during cross-compilation, Portable Types are translated to the corresponding language-specific types.
%
Substantially, the portable types act as a small standard library for this module, written in a subsetted version of Scala that is limited, in its expressiveness, to the constructs that can be mapped and exported to all supported programming languages.
%
An overview of this mapping and the exchange of data structures across different programming languages is presented in \Cref{fig:portable-types-mapping}.
%
\begin{figure}[htbp]
    \centering
    \includegraphics[width=\textwidth]{resources/img/portable-types-mapping.pdf}
    \caption[Language-Agnostic API access through Portable Libraries and isomorphic type mappings]{Language-Agnostic API access through Portable Libraries and isomorphic type mappings enabling to expose a unified interface across multiple programming languages, while delegating the implementation to the core library.}
    % Clients interact with the core library API through Portable Libraries, which expose a simplified interface towards the core library using Portable Types. Thanks to language-specific instantiations of Portable Types and appropriate isomorphic mappings, Portable Libraries simply delegate calls to the core library API after converting Portable Types to their corresponding Scala types.
    \label{fig:portable-types-mapping}
\end{figure}

Beyond collection-types, each Portable Library can extend the set of portable types by defining domain-specific Abstract Data Types (ADTs) that model the library domain, mirroring standard type definition practices.
%
These ADTs maintain the same isomorphic mapping principle, ensuring seamless conversion between portable and Scala types.

Implementation-wise, Portable Libraries are structured as a thin wrapper around the core library API, using only Portable Types in their public interface.
%
Internally, the logic is delegated to the core library after converting Portable Types to their corresponding Scala types using the provided isomorphic mappings.

Notably, the polyglot abstraction layer must account for fundamental differences across all supported programming languages, modeling and abstracting these distinctions to enable their exposure through a unified API. These differences encompass:
%
\begin{itemize}
\item error handling mechanisms, such as exceptions in JavaScript versus error codes in C;
\item API design paradigms, including asynchronous versus synchronous approaches;
\item equality and hashing semantics;
\item memory management models.
\end{itemize}
%
\Cref{chapter:scafi3-arch-reification} presents how Portable Types and Portable Libraries can be implemented to model and abstract these language-level differences.

\section{Consequences}

This architecture enables the development of cross-platform, polyglot and distributed Scala libraries and frameworks by addressing the challenges associated with platform heterogeneity, language interoperability and distributed communication.
%
It's main focus is to maximize code sharing and reuse across all supported platforms and programming languages, while minimizing platform-specific code and complexity and provide a consistent and unified API to library users.

However, some considerations and trade-offs are presented hereafter:
%
\begin{enumerate}
    \item \textit{API Maintenance:} while every code change in the core library is automatically reflected across all supported platforms and runtimes, the addition of new API functionalities requires extending the polyglot abstraction layer to expose the new features to library users. Despite not being a significant overhead, since the polyglot abstraction layer is designed to be thin and minimal, it still requires some additional effort to maintain and evolve;
    \item \textit{Performance Overhead:} Interoperability across programming languages is achieved through type conversion, which introduces performance overhead, particularly when handling complex data structures or large data volumes. However, this overhead remains significantly lower than alternative approaches based on remote procedure calls (RPC) or inter-process communication (IPC), which incur additional serialization and network/process boundary crossing costs;
    \item \textit{Data Expressiveness:} the expressiveness of exchanged messages between nodes is limited to the capabilities of the adopted cross-platform and polyglot serialization format. Complex data structures or language-specific constructs may not be fully representable, potentially requiring simplifications or alternative representations.
\end{enumerate}
