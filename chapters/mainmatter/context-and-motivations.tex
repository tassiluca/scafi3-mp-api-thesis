% !TeX root = ../../main.tex
\chapter{Context and Motivations}

This chapter sets the context and motivations behind the thesis work.
%
First, the fundamentals of Aggregate Computing are introduced.
%
Next, interest in portability and language interoperability in this field is explained, along with the motivations behind this thesis project.
%
Finally, an overview of the Scala 3 implementation of Aggregate Computing is provided, which will be extended in this work.

\section{Aggregate computing: a bird's eye view}

In the realm of complex large-scale systems composed of many interconnected devices, such as Internet of Things (IoT) ecosystems and swarm robotics, traditional approaches to programming individual devices struggle to cope with the scalability, composability, fault-tolerance and declarativeness required to manage such systems effectively.

Aggregate Computing \cite{ac} is an emergent research paradigm aiming at programming such systems through the lens of \textit{macro-programming}.
%
Its core philosophy grounds on the idea of programming the collective behavior of the system as a whole rather than on the individual behavior of its components.
%
Following this principle, developers can write a single program representing the desired global behavior, which emerges in a self-organized manner from the interactions of individual devices.
%
The paradigm embraces functional programming principles to ensure composability and modularity of programs, allowing developers to build complex systems in a succinct and declarative manner, abstracting away low-level details about communication and coordination among devices.

The Aggregate Computing model is based on a collection of interconnected devices capable of exchanging information between themselves according to a neighboring relation.
%
This establishes a dynamic network topology that can evolve over time as a result of mobility, failure and network delays.
%
Each device's dynamics is modelled as a sequence of asynchronous, discrete computational rounds, each consisting of three phases:
%
\begin{enumerate}[label=\roman*.]
    \item \textit{sense}: the device collects information from the most recent messages received from its neighbors and from its local sensors, through which it can observe its local environment;
    \item \textit{compute}: execute the aggregate program using the updated local context to produce an output (the program's return value) and the messages to be sent to neighbors;
    \item \textit{interact}: the program executes its actuations and sends the messages produced in the compute phase to neighboring devices.
\end{enumerate}

The main abstraction, formalized through the \textit{Field Calculus} \cite{fc}, is that of a \textit{computational field}, more briefly referred to as a \textit{field}.
%
A field is a distributed data structure mapping each device to a local value in a specific point in space-time.
%
Aggregate programs are expressed in terms of fields since they represent the first-class citizens of the paradigm, embodying the \textit{"everything is a field"} philosophy: for example, the program controlling the movement of a swarm of robots can be encoded as a field of vectors, where each device has an associated vector indicating the direction and speed it is moving.

\begin{figure}
    \centering
    \includegraphics[width=\textwidth]{resources/img/field.pdf}
    \caption{A visual representation of a computational \textit{field} and phases of a round.}
    \label{fig:field}
\end{figure}

Computations, in this context, are performed by manipulating fields through \textit{stateful evolution}, \textit{neighborhood interaction} and \textit{domain partitioning} constructs.
%
Those can be expressed by the \texttt{exchange} and \texttt{branch} primitives, formalized in the \textit{Exchange Calculus} (XC) \cite{xc}, a tiny core calculus allowing to express the overall behavior of Aggregate Computing systems:
%
\begin{itemize}
    \item \textit{stateful evolution} of fields over time (rounds) and \textit{neighborhood interaction} are achieved through the \texttt{exchange} primitive:
    %
    \begin{syntax}
        \textcolor{violet!90!black}{\mathbf{exchange}}
        \bigl(
            e_i,\;
            (\underline{n}) \;\Rightarrow\;
            \textcolor{blue!60!black}{\mathbf{return}}\; e_r\;
            \textcolor{blue!60!black}{\mathbf{send}}\; e_s
        \bigr)
    \end{syntax}
    %
    that is evaluated, for each round, as follows:
    \begin{enumerate}[label=\roman*.]
        \item the expression $e_i$ is computed to produce the local initial value $l_i$;
        \item $\underline{n}$ represents the neighboring (\textit{field}) value received from nearby devices for this exchange.
        Notationally, neighboring values are underlined to distinguish them from local values.
        Note that, since a device is always considered a neighbor of itself, its own last local value for this exchange from the previous round is also included in $\underline{n}$. For those neighbors for which no value has been received $l_i$ is used as default. The expression $e_r$ is evaluated to the value to be returned by the exchange, allowing to evolve state over rounds based on the neighborhood context;
        \item the expression $e_s$ is evaluated to produce the values to be sent to neighbors for this exchange in the next round.
    \end{enumerate}

    Often, $e_r$ and $e_s$ coincide; in that case the \texttt{retsend} shorthand is used: 
    %
    \begin{syntax}
        \textcolor{violet!90!black}{\mathbf{exchange}}(e_i, 
            (\underline{n}) \Rightarrow
            \textcolor{blue!60!black}{\mathbf{retsend}}\; e)
    \end{syntax}

    \item \textit{domain partitioning} to manage different sub-collectivities within the overall system: 
    %
    \begin{syntax}
        \textcolor{blue!60!black}{\mathbf{if}}\; (condition) \; 
            \{ e_{true} \} \;
            \textcolor{blue!60!black}{\mathbf{else}}\; \{ e_{false} \}
    \end{syntax}
    %
    that evaluates the \texttt{condition} expression on each device and, depending on its truth value, evaluates either the true branch or the false branch, effectively partitioning the computational field into two sub-fields.
\end{itemize}

Both \texttt{exchange} and \texttt{branch} to work properly rely on \textit{alignment}, the mechanism ensuring the values produced by an exchange are processed only by corresponding exchanges, namely those in the same position within the program structure.
%
This avoids the situation where different exchanges interfere with each other, leading to inconsistent or erroneous behavior when programs contain multiple exchange-expressions in their structure, possibly in different branches of a conditional.

Exchange is powerful enough to express also the \textit{Field Calculus} constructs:
%
\begin{itemize}
    \item \texttt{nbr}, used to access neighbor's values:
    %
    \begin{syntax}
        \textcolor{violet!90!black}{\mathbf{nbr}}(e: A): \underline{A}
        \equiv
        \textcolor{violet!90!black}{\mathbf{exchange}}
        \bigl(
            e,\;
            (\underline{n}) \;\Rightarrow\;
            \textcolor{blue!60!black}{\mathbf{return}}\; \underline{n},\;
            \textcolor{blue!60!black}{\mathbf{send}}\; e
        \bigr)
    \end{syntax}
    %
    \item \texttt{rep}, used to make evolve the local state over rounds based on the result of the same expression in the previous round:
    %
    \begin{syntax}
        \textcolor{violet!90!black}{\mathbf{rep}}(e_i: A)\{(x) \Rightarrow e_n \}: A
        \equiv
        \textcolor{violet!90!black}{\mathbf{exchange}}\bigl(
            e_i,\;
            (\underline{n}) \Rightarrow
            \textcolor{blue!60!black}{\mathbf{retsend}}\; e_n[x := self(\underline{n})]
        \bigr)
    \end{syntax}

    \item \texttt{share}, used to access neighbors' values while computing a new value based on the previous result:
    %
    \begin{syntax}
        \textcolor{violet!90!black}{\mathbf{share}}(e_i: A)\{(\underline{x}) \Rightarrow e_n \}: A
        \equiv&
        self(
            \textcolor{violet!90!black}{\mathbf{exchange}}(
                e_i,\;
                (\underline{n}) \Rightarrow
                \textcolor{blue!60!black}{\mathbf{retsend}}\; e_n
            )
        )
    \end{syntax}
\end{itemize}

On top of these constructs, a set of higher-level building blocks and libraries can be built to facilitate the development of aggregate programs in a composable and declarative manner.
%
These include gradient functions for distance estimation, information spreading mechanisms, state management and time-related constructs to handle stateful and temporal behaviors.

\section{Portability and interoperability in Aggregate Computing}

Aggregate Computing targets large-scale distributed systems made up of many heterogeneous devices, from wearables to embedded and mobile ones, each with distinct hardware and software capabilities.
%
Ensuring portability is therefore a primary concern for deploying aggregate programs effectively.

Historically, the first implementation of Aggregate Computing was \textit{Protelis} \cite{protelis}, a JVM-based, Java-interoperable external domain-specific language (DSL) providing a higher-order aggregate programming language.
%
Then, \textit{ScaFi (Scala Fields)} \cite{scafi} was introduced as a Scala 2 strongly-typed internal DSL leveraging Scala's powerful type system and functional programming features.

Over the years, several other implementations have been developed---or are currently being developed---in different languages, including C++, Kotlin, Rust and Python.
%
These implementations aim to support the widest range of platforms, enabling real-world deployments on edge devices, while taking advantage of each language's and ecosystem's strengths, such as C++ performance optimizations or Python machine and deep learning libraries.
%
However, they were created from scratch, with neither code reuse nor compatibility in mind.
%
Moreover, the lack of a common framework has led to fragmentation of the aggregate ecosystem, leading to a situation where each implementation has its own set of libraries, ad hoc extensions and maturity level.

To address these issues, there has been growing interest towards a framework capable of targeting multiple platforms while offering interoperability with other languages.
%
Such a framework requires a foundational language that can effectively and idiomatically express the abstractions and computational model of Aggregate Computing.
%
Critically, cross-platform support must not come at the expense of expressiveness.
%
Scala emerges as an ideal "super"-language for this purpose, given its strong type system allowing to build powerful DSLs and its functional programming features enabling higher-order abstractions.
%
Moreover, Scala's growing support for multiplatform development calls for an investigation into whether it can be effectively used to build a portable Aggregate Computing framework.

The goal of this work is to explore the feasibility of building such a framework, starting from an existing modern Scala 3 implementation of Aggregate Computing, extending it to support multiple platforms and enabling interoperability with other languages.
%
This exploration is meant to investigate:
%
\begin{itemize}
    \item architectural strategies to design a portable and interoperable layer for Aggregate programming, while maintaining core abstractions and semantics and enabling complete code reuse;
    \item interoperability and distribution strategies enabling seamless data exchange and collective execution across heterogeneous devices and language runtimes;
    \item performance implications, idiomaticity of the resulting APIs and overall effort required to extend and maintain a cross-platform and polyglot API.
\end{itemize}

\section{Scafi3 overview: a Scala 3 library for aggregate programming}

ScaFi3\footnote{\url{https://github.com/scafi/scafi3}} is a modern Scala 3-grounded implementation of Aggregate Computing.
%
Born as a complete re-engineering of the original ScaFi library to leverage the new features and capabilities of Scala 3, it delivers full reified support for fields alongside full implementation of XC constructs.

The project is organized into two modules: the \texttt{core} module, providing the core aggregate language constructs and semantics, and the \texttt{alchemist-incarnation} module, providing integration with Alchemist \cite{alchemist}, a simulator for pervasive, nature- and chemical-inspired, and aggregate computing systems that enable the simulation of large-scale systems.
%
The \texttt{core} module is implemented as a pure Scala 3 module, meaning it has no dependencies on any platform-specific capabilities, making it cross-platform by design.
%
The \texttt{alchemist-incarnation} module, instead, depends on the Alchemist simulator and the JVM platform, thus being limited to JVM-based platforms.

Scafi core DSL and libraries entry-points are implemented leveraging Scala 3 contextual abstractions.
%
More specifically, they are implemented as pure functions in singleton objects, taking as implicit parameters the \textit{language syntaxes}, which provides the necessary capabilities to express the aggregate constructs.
%
These are automatically injected by the ScaFi engine, which is responsible for executing computational rounds: during each round, in the compute phase, the aggregate context is created and implicitly provided when evaluating the aggregate program.

In practice, to write an aggregate program in ScaFi3, the developer defines a type alias representing the required language syntaxes, expressed as intersection type compositions, and then defines the aggregate program as a contextual function over that language.
%
For example, in \Cref{lst:scafi3-gradient-example} a simple aggregate program computing a distance gradient from a source node is shown.
%
The program requires access to field calculus syntax (the \texttt{share} construct) and the distance sensor, allowing to sense the distance from neighboring devices.
%
To achieve this, the \texttt{Lang} type alias is defined as the intersection of the \texttt{AggregateFoundation} root syntax, where the \texttt{DeviceId} type is specialized, the \texttt{FieldCalculusSyntax}, providing field calculus constructs, and \texttt{DistanceSensor}, providing the distance sensor capability.

\begin{minipage}{\linewidth}
    \lstinputlisting[
        language=Scala, 
        caption={A ScaFi3 aggregate program computing a distance gradient from a source node. At every round each device shares with its neighbors the minimum distance with its neighbors, computed as the pointwise sum of the distance values received from neighbors and the sensed distance to them. If the device is a source node, it returns 0.0. Eventually, the gradient value converges to the minimum distance from the nearest source node.},
        label={lst:scafi3-gradient-example},
        linerange={14-22},
    ]{resources/code/Gradient.scala}
\end{minipage}



