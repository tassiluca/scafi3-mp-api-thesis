% !TeX root = ../../main.tex
\chapter{Context and Motivations}

This chapter sets the context and motivations behind the thesis work.
%
First, the fundamentals of Aggregate Computing are introduced.
%
Next, interest in portability and language interoperability in this context is explained, along with the motivations behind this thesis project.
%
Finally, an overview is provided of the Scala implementation of Aggregate Computing, which will be the subject of extension.

\section{Aggregate computing: a bird's eye view}

In the realm of complex large-scale systems composed of many interconnected devices, such as Internet of Things (IoT) ecosystems and swarm robotics, traditional approaches to programming individual devices struggle to cope with the scalability, composability, fault-tolerance and declarativeness required to manage such systems effectively.

Aggregate Computing \todo{cite} is an emergent research paradigm aiming at programming such systems through the lens of \textit{macro-programming}.
%
Its core philosophy grounds on the idea of programming the collective behavior of the system as a whole rather than on the individual behavior of its components.
%
Following this principle, developers can write a single program representing the desired global behavior, which emerges in a self-organized manner from the interactions of individual devices.
%
The paradigm embraces functional programming principles to ensure composability and modularity of programs, allowing developers to build complex systems in a succinct and declarative manner, abstracting away low-level details about communication and coordination among devices.

The Aggregate Computing model is based on a collection of interconnected devices capable of exchanging information between themselves according to a neighboring relation, establishing a dynamic network topology that can evolve over time as a result of mobility, failure and network delays.
%
Each device dynamics is modelled as a sequence of asynchronous, discrete computational rounds, each consisting of three phases:
%
\begin{enumerate}[label=\roman*.]
    \item \textit{sense}: the device collects information from the most recent messages received from its neighbors and from its local sensors, through which it can observe its local environment;
    \item \textit{compute}: execute the aggregate program using the updated local context to produce an output (the program's return value) and the messages to be sent to neighbors;
    \item \textit{interact}: the program executes its actuations and sends the messages produced in the compute phase to neighboring devices.
\end{enumerate}

The main abstraction, formalized through the \textit{Field Calculus} \todo{cite}, is that of a \textit{computational field}, more briefly referred to as a \textit{field}.
%
A field is a distributed data structure mapping each device to a local value with a default in a specific point in space-time.
%
Aggregate programs are expressed in terms of fields since they represent the first-class citizens of the paradigm, embodying the \textit{"everything is a field"} philosophy: for example, the program controlling the movement of a swarm of robots can be encoded as a field of vectors, where each device has an associated vector indicating the direction and speed it is moving.

Computations, in this context, are performed by manipulating fields through \textit{stateful evolution}, \textit{neighborhood interaction} and \textit{domain partitioning} constructs.
%
Those can be expressed by, namely, \texttt{exchange} and \texttt{branch} primitives, formalized in the \textit{Exchange Calculus} \todo{cite}, a tiny core calculus allowing to express the overall behavior of Aggregate Computing systems.
%
\begin{itemize}
    \item \textit{stateful evolution} of fields over time (rounds) and \textit{neighborhood interaction} are achieved through the \texttt{exchange} primitive:
    %
    \begin{syntax}
        \textcolor{violet!90!black}{\mathbf{exchange}}
        \bigl(
            e_i,\;
            (\underline{n}) \;\Rightarrow\;
            \textcolor{blue!60!black}{\mathbf{return}}\; e_r\;
            \textcolor{blue!60!black}{\mathbf{send}}\; e_s
        \bigr)
    \end{syntax}
    %
    that is evaluated, for each round, as follows:
    \begin{itemize}
        \item the expression $e_i$ is computed to produce the local initial value $l_i$;
        \item $\underline{n}$ represents the neighborhood values received from neighboring devices for this exchange.
        Notationally, neighbor values are underlined to distinguish them from local values.
        Note that, since a device is always a neighbor of itself, its own last local value for this exchange from the previous round is also included in $\underline{n}$. For those neighbors for which no value has been received $l_i$ is used as default. The expression $e_r$ is evaluated to the value to be returned by the exchange, allowing to evolve state over rounds based on the neighborhood context;
        \item the expression $e_s$ is evaluated to produce the values to be sent to neighbors for this exchange in the next round.
    \end{itemize}

    \item \textit{domain partitioning} to manage different sub-collectivities within the overall system, achieved by the \texttt{branch} primitive. 
    %
    \begin{syntax}
        \textcolor{violet!90!black}{\mathbf{branch}}
        \bigl(
            condition,\;
            e_{true},\;
            e_{false}
        \bigr)
    \end{syntax}
    %
    that evaluates the \texttt{condition} expression on each device, and depending on its truth value, evaluates either the true branch or the false branch, effectively partitioning the computational field into two sub-fields.
\end{itemize}

Both \texttt{exchange} and \texttt{branch} to work properly rely on \textit{alignment}, the mechanism ensuring the values produced by an exchange are processed only by corresponding exchanges, namely those in the same position within the program structure.
%
This avoids the situation where different exchanges interfere with each other, leading to inconsistent or erroneous behavior when programs contain multiple exchange-expressions in their structure, possibly in different branches of a conditional.

Exchange is powerful enough to express also the \textit{Field Calculus} constructs:
%
\begin{itemize}
    \item \texttt{nbr}, used to access \textit{neighbor's values}:
    %
    \begin{syntax}
        \textcolor{violet!90!black}{\mathbf{nbr}}(e: A): \underline{A}
        \equiv
        \textcolor{violet!90!black}{\mathbf{exchange}}
        \bigl(
            e,\;
            (\underline{n}) \;\Rightarrow\;
            \textcolor{blue!60!black}{\mathbf{return}}\; \underline{n},\;
            \textcolor{blue!60!black}{\mathbf{send}}\; e
        \bigr)
    \end{syntax}
    %
    \item \texttt{evolve}, used to make evolve the local state over rounds based on the result of the same expression in the previous round:
    %
    \begin{syntax}
        \textcolor{violet!90!black}{\mathbf{evolve}}(init: A)\{(x: A) \Rightarrow e_n \}: A
        \equiv
        \textcolor{violet!90!black}{\mathbf{exchange}}\bigl(
            init,\;
            (\underline{n}) \Rightarrow
            \textcolor{blue!60!black}{\mathbf{retsend}}\; \underline{n}(self)
        \bigr)
    \end{syntax}

    \item \texttt{share}, used to access neighbors' values while computing a new value based on the previous result:
    %
    \begin{syntax}
        \textcolor{violet!90!black}{\mathbf{share}}(init: A)\{(x: A) \Rightarrow e_n \}: A
        \equiv&
        self(
            \textcolor{violet!90!black}{\mathbf{exchange}}(
                init,\;
                (\underline{n}) \Rightarrow
                \textcolor{blue!60!black}{\mathbf{retsend}}\; e_n
            )
        )
    \end{syntax}
\end{itemize}

\todo{complete with FC syntax}

On top of these constructs, a set of higher-level building blocks and libraries is provided to facilitate the development of aggregate programs in a composable and declarative manner.

\todo{some example?}

\section{Portability and interoperability in Aggregate Computing}

The nature of Aggregate Computing, with its focus on large scale distributed systems composed of a multitude of heterogeneous devices, spanning from wearables devices to embedded and mobile devices,  each with its own hardware and software capabilities, makes portability a primary concern for the effective deployment of aggregate programs.

Historically, the first implementation of Aggregate Computing was \textit{Protelis} \todo{cite}, a JVM-based, Java-interoperable external domain-specific language (DSL) providing a higher-order aggregate programming language.
%
Then, \textit{ScaFi (Scala Fields)} \todo{cite} was introduced as a Scala 2 strongly-typed internal DSL leveraging Scala's powerful type system and functional programming features.

Over the years, several other implementations have been developed or are in the process of being developed in different languages, including C++, Kotlin, Rust and Python.
%
The rationale behind these multiple implementations is to reach the widest possible range of platforms, enabling real-world deployments on edge devices, or to leverage the unique strengths of each programming language and its ecosystem, such as performance optimizations in C++ or Python Machine and Deep Learning libraries.
%
However, each of these implementations have been created from scratch, with no code reuse and no compatibility in mind.
%
Moreover, the lack of a common framework has led to fragmentation of the aggregate ecosystem, leading to a situation where each implementation has its own set of libraries, ad hoc extensions and maturity level.

To address these issues, there has been growing interest towards a framework capable of targeting multiple platforms while offering interoperability with other languages.
%
Such a framework requires a foundational language that can effectively and idiomatically express the abstractions and computational model of Aggregate Computing.
%
Critically, cross-platform support must not come at the expense of expressiveness.
%
Scala emerges as an ideal "super"-language for this purpose, given its strong type system allowing to build powerful DSLs and its functional programming features enabling higher-order abstractions.
%
Moreover, Scala's growing support for multiplatform development ask for investigation whether it can be effectively leveraged to build a portable Aggregate Computing framework.

The goal of this work is to explore the feasibility of building such a framework, starting from an existing modern Scala 3 implementation of Aggregate Computing, extending it to support multiple platforms and enabling interoperability with other languages.
%
This exploration is meant to investigate:
%
\begin{itemize}
    \item architectural strategies to design a portable and interoperable layer for Aggregate programming while maintaining core abstractions and semantics intact with complete code reuse;
    \item interoperability strategies to enable seamless communication and data exchange between aggregate programs implemented in different languages, allowing to distribute a collectiveness across heterogeneous devices with different language runtimes;
    \item performance implications, idiomaticity of the resulting APIs and overall effort required to extend and maintain the cross-platform framework, through comprehensive benchmarks and case studies.
\end{itemize}

\section{Scafi3 overview: a Scala 3 library for aggregate programming}

