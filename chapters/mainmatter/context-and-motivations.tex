% !TeX root = ../../main.tex
\chapter{Context and Motivations}

This chapter sets the context and motivations behind the thesis work.
%
First, the fundamentals of Aggregate Computing are introduced.
%
Next, interest in portability and language interoperability in this context is explained, along with the motivations behind this thesis project.
%
Finally, an overview is provided of the Scala implementation of Aggregate Computing, which will be the subject of extension.

\section{Aggregate computing: a bird's eye view}

In the realm of complex large-scale systems composed of many interconnected devices, such as Internet of Things (IoT) ecosystems and swarm robotics, traditional approaches to programming individual devices struggle to cope with the scalability, composability, fault-tolerance and declarativeness required to manage such systems effectively.

Aggregate Computing \todo{cite} is an emergent research paradigm aiming at programming such systems through the lens of \textit{macro-programming}.
%
Its core philosophy grounds on the idea of programming the collective behavior of the system as a whole rather than on the individual behavior of its components.
%
Following this principle, developers can write a single program representing the desired global behavior, which emerges in a self-organized manner from the interactions of individual devices.
%
The paradigm embraces functional programming principles to ensure composability and modularity of programs, allowing developers to build complex systems in a succinct and declarative manner, abstracting away low-level details about communication and coordination among devices.

The Aggregate Computing model is based on a collection of interconnected devices according to a neighboring relation, establishing a dynamic network topology that can evolve over time as a result of mobility, failure and network delays.
%
Each device dynamics is modelled as a sequence of asynchronous, discrete computational rounds, each consisting of three phases:
%
\begin{enumerate}[label=\roman*.]
    \item \textit{sense}: the device collects information from local sensors through which it can observe its local environment and sent by its neighbors in the previous round to update its local context;
    \item \textit{compute}: execute the aggregate program using the updated local context to produce an output (the program's return value) and the messages to be sent to neighbors;
    \item \textit{interact}: the program executes its actuations and sends the messages produced in the compute phase to neighboring devices.
\end{enumerate}

The main abstraction, formalized through the \textit{Field Calculus} \todo{cite}, is that of a \textit{computational field}, more briefly referred to as a \textit{field}.
%
A field is a distributed data structure mapping each device of the collectivity to a local value.
%
Aggregate programs are expressed over fields since they represent the first-class citizens of the paradigm, embodying the \textit{"everything is a field"} philosophy: for example, the program controlling the movement of a swarm of robots can be encoded as a field of vectors, where each device has an associated vector indicating the direction and speed it is moving.
%
Fields are then manipulated through three kind of constructs:
%
\begin{itemize}
    \item \textit{stateful evolution} of fields over time (rounds);
    \item \textit{neighbour interaction} to exchange information, enabling spatial evolution;
    \item \textit{domain partitioning} to manage different sub-collectivities within the overall system.
\end{itemize}

Both stateful evolution and neighbor interaction are embodied in a single operator called \texttt{exchange}:

\subsection{Portability and interoperability in Aggregate Computing}

\section{Scafi3 overview: a Scala 3 library for aggregate programming}

\todo{Why Scala as super language for multiplatform aggregate computing?}
