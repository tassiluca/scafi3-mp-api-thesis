% !TeX root = ../../main.tex
\chapter{Background and Related Work}

This chapter provides the reader the background behind the concepts of software portability, multi-platform software development and interoperability between programming languages, unfolding how these concepts play a crucial role in the comprehensive software lifecycle and why they are relevant in modern software engineering.
%
Finally, the main cross-platform polyglot languages are reviewed, with a particular focus on Scala.

\section{The role of portability in Software Engineering}

Software \textit{portability} refers to the ability of a software artifact to be used in a diverse range of platforms and environments.
%
In this context, the term \textit{platform} primarily denotes the combination of hardware architecture and operating system, though it is often extended to include the execution runtime \cite{ElKassas2017}.
%
The term \textit{environment}, instead, represents the broader collection of external elements with which the software interacts, including system interfaces and libraries.
%
In essence, a software artifact is portable, i.e., it exhibits portability, when the cost required to design and implement it for porting to multiple platforms does not exceed the cost of re-development for each of them \cite{Mooney}.
%
Portability is, therefore, about engineering software products to maximize components reuse while ensuring consistent behavior across target platforms.

Portability spans over multiple levels \cite{Mooney}:

\begin{itemize}
    \item \textit{source portability} occurs when the software is adapted to the underlying platform by changing the source code, which is then recompiled for the target platform. This is the most common form of portability;
    \item \textit{binary portability} involves porting software in its compiled binary format. This is the most advantageous form of portability, though it is also the most difficult to achieve and is limited to specific cases;
    \item \textit{intermediate-level portability} is a middle-ground between source and binary portability and entails porting an intermediate representation of the software, sitting between the source and binary code.
\end{itemize}

Portability has always been a relevant concern in software engineering since the early days of computing, when the landscape of hardware architectures and operating systems was extremely fragmented and heterogeneous, and software was tightly coupled to the underlying platform, requiring full rewrites when moving to a different one \cite{Randal2020}.
%
Over time, the situation has profoundly changed thanks to a series of innovations and efforts: from the standardization of operating systems interfaces, such as POSIX, to the widespread introduction of increasingly higher-level programming languages and the diffusion of modern paradigms, like the World Wide Web, that inherently fostered portability.

From a programming language perspective, one influential shift addressing portability has been the move from compilation-based to virtual machine-based approaches, such as the Java Virtual Machine (JVM) and the Common Language Runtime (CLR) for .NET.
%
These emerged to overcome the limitations of traditional compilation-based approaches, like C and C++, that require developers to create and maintain separate binaries for each target platform, often with platform-specific code and complex build configurations---a costly and time-consuming process.
%
Virtual machine approaches addressed these challenges through an additional abstraction layer, decoupling the software from the underlying platform by compiling programs into an Intermediate Representation (IR), like the Java bytecode, that is then interpreted or just-in-time compiled by a platform-specific runtime.
%
This approach has found widespread adoption, with the JVM and CLR becoming the backbone of entire ecosystems of modern languages and frameworks and enabling the famous \enquote{write once, run anywhere} paradigm---the promise that applications would be portable across any platform supporting the respective runtime.

However, the technical reality proved to be more nuanced: different virtual machine implementations can exhibit subtle differences in behavior, and, in resource-constrained environments, the overhead imposed by the virtual machine may be prohibitive.

Contemporary portability solutions continue this abstraction progression, with modern languages supporting multi-target compilation to various platforms, including JVM, JavaScript, WebAssembly and native binaries using IRs.

However, despite the advancements in portability techniques and tools, achieving portability remains a complex challenge as it requires ensuring consistent behavior across diverse platforms and environments that often differ in their capabilities and constraints.
%
To illustrate, consider the differences between platforms in terms of concurrency models.
%
Nowadays, most applications are designed to take advantage of multicore architectures and heavily rely on concurrency to speed up computations or to handle multiple tasks simultaneously.
%
Nevertheless, not all platforms support this feature equally.
%
For instance, the Node JS platform, widely used for server-side and web applications, is based on a single-threaded event loop model where blocking operations cannot be performed, requiring a completely different paradigm based on Continuation-Passing Style and asynchronous programming.

Such fundamental differences in platform capabilities are concern permeating all stages of the software lifecycle, from design to release, requiring careful analysis.

\vspace{0.5em}
\noindent
\textbf{Design and implementation.}
%
When designing software, architects must consider the targeted platforms' constraints and capabilities to minimize the \textit{abstraction gap} between the domain problem and platform abstractions.
%
The greater the abstraction gap is, the more challenging it becomes to implement the required functionalities in a clean, well-structured and maintainable way.
%
In this context, the maturity of a platform's ecosystem, in terms of libraries and frameworks availability, significantly reduces the abstraction gap developers must bridge, influencing the platform choice.
%
For example, if a software product requires advanced data analysis and machine learning capabilities, targeting a platform with a rich ecosystem in this domain, such as Python, would be a wise choice.

This is particularly relevant when targeting multiple platforms, as the abstraction gap may be significantly higher with respect to a single platform scenario.
%
As Doeraene notes in \cite{doeraene-2018}, portability is not enough: even if a language is portable, unless the ecosystem publishes portable libraries, it remains difficult to develop applications spanning multiple runtimes because of development costs.

\vspace{0.4em}
\noindent
\textbf{Testing.}
%
Having a multi-platform stack significantly impacts the testing strategy, as artifacts need to be tested on each of the targeted platforms to ensure they behave correctly and consistently across them.
%
Furthermore, different architectures may behave differently under the same platform (e.g., ARM vs. x86 in native execution), requiring additional testing efforts to cover all the supported architectures.

\vspace{0.4em}

\noindent
\textbf{Release.}
%
Releasing a multi-platform software product introduces significant complexity, as each platform has its own conventions and requirements for packaging, distributing, versioning and deployment.
%
For example, JVM artifacts are distributed as JARs via Maven Central, JavaScript applications via npm bundles such as Webpack, and Python packages as wheels via PyPI.

\vspace{0.4em}

Despite the challenges, portability remains a crucial aspect of modern software engineering, driven by the need to reach heterogeneous infrastructures and reduce the burden of maintaining or re-implementing software for different platforms.
%
Without it, developers face fragmentation, inconsistencies between the different versions and increased maintenance costs.

\section{Language interoperability}

Portability is only one side of the coin.
%
Orthogonally to the platform dimension, \textit{language interoperability} is equally important, as it refers to the ability to communicate with other languages on each targeted platform, guaranteeing uniformity in semantics across them \cite{doeraene-2018}.
%
Having portability without interoperability is of limited practical use: while portability make it possible to use software artifacts in different platforms, the lack of interoperability with their APIs and libraries would make the software product isolated and unable to interact with the surrounding ecosystem.
%
For example, developing an application targeting the JavaScript platform without being able to access its specific functionalities, such as manipulating the DOM, handling user events or performing file system operations leveraging Node.js API, would make portability largely theoretical rather than practical.

Interoperability, however, extends beyond accessing native APIs: it entails the responsibility for library developers to expose the library interfaces in the target language.
%
This enables the widest possible developers' audience to use the library and, most importantly, to let them integrate it with the full power of the underlying ecosystem.
%
This is particularly relevant because platform ecosystems have been evolved in silos over the years; they often lack interoperability with each other, and each of them is focused and optimized for specific domains and use cases.
%
Language interoperability therefore allows, together with portability, developers to choose the best platform and, consequently, the best library API for their specific needs, minimizing the risk of incurring in incompatibility issues.

Crafting a ``good'' language-interoperable layer is a complex task whose main difficulty lies in the mismatch between the run-time semantics and abstractions of the involved languages.
%
This includes, among others, dealing with different memory management strategies (e.g., garbage collection vs manual memory management), type systems (e.g., static vs dynamic typing, strong vs weak typing), and error handling mechanisms (e.g., exceptions vs error codes). 
%
Sometimes, these differences cannot be fully bridged: some features of the source language can be dropped or limited on a case-by-case basis if they cannot be mapped to the target language and are not essential for the target ecosystem.
%
For example, most of the runtime reflection capabilities available in JVM-based languages may not be fully supported when interoperating with other languages.
%
However, the key point about interoperability is that the implemented features must be complete with respect to the semantics of the host language, ensuring compatibility with any library in its ecosystem \cite{doeraene-2018}.

\section{Approaches to multi-platform and polyglotism}
\label{sec:approaches-to-multi-platform-and-polyglotism}

While various categorizations of cross-platform approaches exist in literature \cite{ElKassas2017}, two fundamental mechanisms can be distinguished: \textit{cross-compilation} and \textit{wrapper-based} approaches.

In the cross-compilation approach, the source code is written in a sort of \enquote{superset} language that is automatically compiled and/or transpiled to different platform-specific targets thanks to a dedicated toolchain, generating platform-specific artifacts.
%
In this approach the source language itself is designed to provide both portability and interoperability with each target platform and is referred to as \textit{cross-platform language} \cite{doeraene-2018}.
%
Despite having a single super language that can be cross-compiled to different targets, that does not mean that all the code can be shared across all the platforms.
%
Thus, when embracing this approach, the main goal is to design the software product to maximize the reusability of its components across the different targeted platforms and fill the abstraction gap with each environment via minimal platform-specific code, leveraging, whenever possible, cross-platform libraries.
%
The primary advantage of this approach is that it enables sharing a substantial portion of the codebase across different platforms.
%
Indeed, when core business logic is designed to be technologically agnostic---as best practices prescribe---it can typically be, for the most part, if not completely, shared across all the platforms.
%
In this respect, striving to maximize code sharing, though it may require more effort initially, pays off in the long run as it is synonymous with better design.

The other approach is the wrapper-based one, which consists in developing the software product on a main platform and language, and exposing its functionalities to others via a dedicated interoperability layer, typically implemented as a wrapper library through \textit{Foreign Function Interfaces} (FFI).
%
These interfaces require dedicated runtime support and often rely on C as a common interoperability \textit{lingua franca}, due to its widespread use in interfacing with low-level operating system APIs and system libraries.
%
For example, many interpreted languages, such as Python, include mechanisms for executing extensions modules written in lower-level languages like C or C++, which are dynamically loaded into the high-level language's virtual machine at runtime \cite{Grimmer-2018}.

Over the years, automated binding generation tools have been developed to simplify the creation of interoperability layers.
%
A well known example is the Simplified Wrapper and Interface Generator (SWIG) \cite{Beazley2003}, which can generate language bindings from C and C++ header files to a variety of high-level languages, including Python, Java, JavaScript, Ruby and others.
%
Unlike the cross-compilation approach, in the absence of automated tools, wrapper modules must be implemented manually---a process that can be complex, error-prone and that does not scale well if the number of target languages increases.

\subsection{The case of Scala}

Scala is a modern multi-paradigm programming language seamlessly integrating both object-oriented and functional programming, whose powerful static type system and advanced language abstraction features make it suitable for crafting complex and maintainable software systems in a concise, elegant and expressive way.

Originally designed to run on the JVM and interoperate with Java, Scala has evolved to support also native and JavaScript platforms making it a cross-platform language.
%
Despite other languages, Scala's cross-platform capabilities are not tied to the language itself but, rather, demanded by dedicated projects, each with its own compiler plugins and toolchains that extend the Scala compiler and ecosystem.

\subsubsection{Scala.js}

Scala.js\footnote{\url{https://www.scala-js.org}} is the project, introduced in 2013 at EPFL, meant to compile Scala code to JavaScript with the goal of enabling developers to write rich web applications entirely in Scala and having them compiled to ready to run JavaScript code \cite{doeraene-2018}.
%
Over the years Scala.js has matured into a stable project that allows to target both web browsers and the Node.js backend environment, making it suitable for developing full-stack applications entirely in Scala.
%
More recently, an experimental support for WebAssembly has also been introduced.

Compilation to JavaScript is achieved via a pipeline of stages, shown in \Cref{fig:scala-js-compiler-pipeline}, performed after the Scala frontend compiler have parsed and type-checked the source code:

\begin{itemize}
    \item in the first stage the Scala.js compiler turns Scala AST into an IR (\texttt{.sjsir}) specifically designed to provide both portability and interoperability;
    \item then, \texttt{.sjsir} files are linked together, type-checked and optimized. Optimizations include, among others, methods inlining at call sites and dead code elimination to make sure only exported API is kept, significantly reducing the final code size;
    \item finally, the optimized IR is compiled into a single \texttt{.[m]js} file containing the JavaScript code ready to be executed in the JavaScript environment.
\end{itemize}

\begin{figure}
    \centering
    \includegraphics[width=\textwidth]{resources/img/scala-js-pipeline.pdf}
    \caption{Scala.js simplified compiler pipeline.}
    \label{fig:scala-js-compiler-pipeline}
\end{figure}

The fact this compilation pipeline is attached to the standard Scala compiler allows supporting whole Scala language, including all advanced features and abstractions.

As for interoperability, Scala.js seamlessly integrates with existing JavaScript libraries and frameworks, thanks to a dedicated interoperability layer enabling both the consumption of JavaScript APIs and the exposure of Scala.js libraries to JavaScript code.
%
Scala.js-specific code can therefore invoke JavaScript functions and interact with any library available in the JavaScript ecosystem, including the Node.js standard library, through typed facades mapping JavaScript APIs to Scala.js types and abstractions.
%
These can be manually written or, more commonly, automatically generated 
using ScalablyTyped\footnote{\url{https://scalablytyped.org/}}, a tool that converts TypeScript declaration files 
(\texttt{.d.ts}) into Scala.js facades via a Scala Build Tool (sbt) plugin.
%
Conversely, software products APIs can be exposed to JavaScript code by annotating Scala.js classes and methods, instructing the compiler to generate the necessary bindings.
%
Unfortunately, the project does not support automatic generation of TypeScript type definitions from Scala.js APIs, which would greatly facilitate the consumption of Scala.js libraries from TypeScript code (and there are no plans to support this in the future\footnote{\url{https://github.com/scala-js/scala-js/issues/3836\#issuecomment-551273036}}).

To maximize code reuse across the JVM and JavaScript platforms, subsets of the Scala and Java standard libraries have been re-implemented to work natively in the JavaScript environment, providing almost equivalent semantics of their JVM counterparts: some differences are due to the inherent distinctions between the two platforms (e.g., the fact only \texttt{Double}s are supported as numeric types in JavaScript) \cite{doeraene-2018}.
%
A notable example of reusable standard library API is the Future-based concurrency model which, under the hood, impacts the JavaScript event-loop model while exposing the same API available on the JVM platform.
%
Nevertheless, not all the JVM standard library can be ported; for instance, blocking I/O operations are incompatible with the JavaScript's asynchronous, non-blocking I/O model.
%
When designing a cross-platform library, it is therefore essential to carefully evaluate which parts of the code can be shared and which need to be platform-specific, ensuring shared code relies only on cross-platform abstractions; for example, no blocking calls are performed.

\subsubsection{Scala Native}

Following the success of Scala.js, the Scala Native\footnote{\url{https://www.scala-native.org/}} project moved their first steps in 2017 as a research project at EPFL.
%
Its goal is to compile Scala code directly to bare-metal machine code without the need for the JVM, making it suitable for resource-constrained environments where the overhead imposed by the JVM in terms of memory footprint and startup time cannot be tolerated.
%
Since the 0.5 release, published in 2024 with the introduction of native concurrency primitives, the project has reached a decent level of maturity and stability, making it viable for production use.

Scala Native is both an \textit{ahead of time} (AOT) compiler and standalone runtime.

The AOT compiler translates Scala code into native machine code leveraging the LLVM toolchain \cite{Lattner}, a widely adopted modular compiler infrastructure for producing optimized machine code for multiple architectures. 
%
Compilation proceeds, similarly to Scala.js, through a pipeline of stages, shown in \Cref{fig:scala-native-compiler-pipeline}, performed after the Scala frontend compiler, producing IR files from which the final machine code is generated:

\begin{itemize}
    \item the first stage of the pipeline is performed by the \texttt{nscplugin} that, inspecting the abstract syntax tree, translates the Scala code into a strongly typed Native IR (NIR) consisting of a subset of LLVM IR instructions enriched with additional information to support Scala high level abstractions;
    \item NIR files are then linked together with those generated from external libraries and optimized;
    \item finally, the optimized NIR is translated to low-level LLVM instructions that are then compiled by the LLVM backend to platform-specific machine code.
\end{itemize}

\begin{figure}
    \centering
    \includegraphics[width=\textwidth]{resources/img/scala-native-pipeline.pdf}
    \caption{Scala Native simplified compiler pipeline.}
    \label{fig:scala-native-compiler-pipeline}
\end{figure}

Other than the compiler itself, Scala Native includes a lightweight runtime layer that supplies essential services for the program execution.
%
Most notable features provided by the runtime are:

\begin{itemize}
    \item a configurable garbage collector for automatic memory management of heap-allocated Scala objects;
    \item a threading model, based on native OS threads, which maps Scala's concurrency abstractions to the underlying platform while striving to maintain maximum semantic compatibility with the JVM;
    \item most of the Scala and Java standard libraries re-implemented to work natively with the same semantics (Scala Native treats any differences in semantics between the two platforms as a bug).
    \item foreign function and a subset of C interoperability primitives to interface with existing C or C++ libraries and native code through type facades. These can be generated, similarly to Scala.js, via the sbt binding generator plugin\footnote{\url{https://sn-bindgen.indoorvivants.com}}, which processes C header files and produces Scala Native facades.
    Scala Native can also expose its libraries to C code via annotations, though currently only static object methods and properties (via accessor methods) can be exported and no automatic generation of C headers is provided.
\end{itemize}

Concerning the supported architectures and operating systems, Scala Native can target AMD64 (\texttt{x86-64}) and ARM64 (\texttt{aarch64}) architectures on Linux, macOS and Windows operating systems, also thanks to cross-compilation support---the ability to compile code for a different target architecture and/or OS than the one of the host machine where the compilation is performed.
%
This covers the vast majority of modern desktop and server environments, including some System-on-Chip (SoC) architectures, like Raspberry Pi devices.
%
Experimental or partial support exists for FreeBSD, OpenBSD, and NetBSD, though sometimes limited to particular architectures (e.g., only AMD64 on OpenBSD). 
%
Moreover, with the 0.5 release, Scala Native introduced experimental support for 32-bit architectures, like ARMv7.
%
Mobile platforms (such as Apple devices) and microcontroller architectures (like ESP32 architecture) are not supported: the first due to the lack of support for Objective-C or Swift interoperability, required for accessing Apple's frameworks, and the latter because of the limited resources offered by these devices.
%
While the first limitation could be overcome in the future, the second will hardly be addressed because of the usage of limited or not fully mature LLVM support and the fact that compiled executable include a runtime layer that, alone, requires a few megabytes of memory that typically microcontrollers cannot accommodate.

\subsubsection{Cross-platform ecosystem}

A brief analysis of the multi-platform ecosystem state is presented.

The fact that the native and JavaScript platforms are targeted by separate projects, each with its own release cycles and levels of maturity, introduces fragmentation in the ecosystem.
%
Comparing Scala.js and Scala Native, it is evident the former has reached a higher level of maturity and stability, driven by its broader audience and interest in web development.
%
For this reason, the level of library support for Scala.js is higher with respect to Scala Native.
%
Nevertheless, native platform has made significant progress in recent years, and since the introduction of native concurrency primitives, many libraries---such as those in the popular ZIO \footnote{\url{https://zio.dev}} and Typelevel \footnote{\url{https://typelevel.org}} ecosystems---have been ported or are in the process of being ported.
%
Of course, porting libraries across all platforms requires time and effort, especially when done retrospectively.
%
Therefore, it is expected that in the coming years, the landscape of cross-platform Scala libraries will continue to improve and the number of libraries supporting both Scala.js and Scala Native will increase, driven by the growing adoption and success of both platforms.

Concerning language interoperability, the Scala ecosystem currently lacks production ready libraries exposing a unified and coherent cross-platform, polyglot API.
%
However, despite the challenges and limitations introduced above that will be discussed in the next chapters, both Scala.js and Scala Native provide layers of interoperability that, if properly leveraged, provide a foundation for such solutions, on which this thesis aims to contribute.

\subsection{Related works}

Besides Scala, other languages and frameworks exist targeting multiple platforms and providing language interoperability features.
%
Among these the most notable examples are Kotlin Multiplatform, Gleam, Haxe and Flutter/Dart.

\subsubsection{Kotlin Multiplatform}

Kotlin Multiplatform\footnote{\url{https://www.jetbrains.com/help/kotlin-multiplatform-dev/}} is Scala's primary competitor in both the JVM and cross-platform ecosystems, as it supports object-oriented and functional paradigms---albeit with less advanced abstractions than Scala---and targets comparable architectures: rooted in the JVM, it supports JavaScript, native platforms via LLVM, and, experimentally, WebAssembly.

Officially supported by JetBrains, Kotlin Multiplatform has gained significant traction in recent years, particularly in mobile development, after Google adopted it as the official language for Android.
%
Its widespread use in the mobile development community, where cross-platform development is crucial, together with JetBrains' unified management, has fostered the growth of a robust, rich and continuously improving ecosystem that is expected to further expand in the coming years.
%
Thanks to this mobile-oriented focus, Kotlin Multiplatform also supports native Apple devices, currently missing in Scala Native.
%
However, similarly to Scala, it cannot target microcontroller architectures because its large runtime requirements and limited LLVM support.

% ... Concerning cross-platform code sharing, Kotlin MP follows a similar philosophy to Scala, providing a hierarchical modules structure, rooted in a common module containing platform-agnostic code, extended by platform-specific modules.

In terms of language interoperability, Kotlin Multiplatform offers strong integration with JavaScript, C, and Swift/Objective-C, other than Java.
%
As in Scala, API exposure is achieved via annotations, instructing the compiler to generate the necessary bindings.
%
Notable toolchain features in this context include the automatic generation of C headers and, experimentally, TypeScript declaration files, thereby minimizing manual integration effort.

\subsubsection{Gleam}

Gleam\footnote{\url{https://gleam.run}} is an emergent general-purpose, statically-typed functional programming language.
%
Guided by a minimalistic design philosophy, it emphasizes simplicity and ease of use, forgoing object-oriented constructs and advanced functional abstractions, such as type classes, in favor of first-class functions, algebraic data types and pattern matching.

The language provides two distinct compilation targets: the BEAM virtual machine and JavaScript.
%
Targeting the BEAM VM allows Gleam to leverage server-side battle-tested Erlang ecosystem, renowned for its fault-tolerance, massive actor-based concurrency capabilities and distributed computing features.
%
On the other hand, the JavaScript target enables Gleam to be used in web development, both on the client and server-side via Node.js.

Gleam targets these platforms employing a source-to-source transpilation approach, whereby it transpiles its source code into human-readable and pretty-printed Erlang or JavaScript code with TypeScript declaration files.
%
This allows full interoperability with the BEAM and JavaScript ecosystems through annotations and type facades, and allows developers to inspect and debug the generated code directly.
%
However, since the lack of hierarchical modules structure like Scala's or Kotlin's, this architectural choice introduces significant limitations when dealing with platform-specific incompatible abstractions, like I/O and concurrency.
%
When targeting the Erlang's platform, concurrency is managed transparently by the BEAM runtime.
%
In contrast, the JavaScript target requires explicit handling of concurrency via promises or callbacks to accommodate the event-loop model.
%
Consequently, programming styles and constructs differ between targets: code employing Erlang-style concurrency I/O cannot be transpiled to JavaScript and vice versa.
%
Therefore, libraries that make use of concurrent I/O need to decide whether to target one platform or the other, limiting code sharing.

This positions Gleam as a language suitable for full-stack development, allowing developers to write both backend and frontend code in the same language, rather than offering complete cross-platform capabilities.

\subsubsection{Haxe}

Haxe\footnote{\url{https://haxe.org}} is general-purpose cross-platform language, primarily designed to target a large variety of platforms and programming languages, including JavaScript, PHP, Python, Lua, C++, Java and C\#, on a wide range of architectures and operating systems, including Android and Apple iOS.
%
The language is strictly-typed, object-oriented, featuring an ECMAScript-oriented syntax, similar to JavaScript and Java.

Its cross-platform capabilities are achieved via a hybrid compilation strategy.
%
The Haxe language can both compile into bytecode to be executed on JVM or its own Virtual Machines (HashLink and NekoVM) and it can also transpile into other high-level languages.
%
It features a platform-agnostic standard library and an ecosystem of cross-platform libraries, supporting most of the necessary functionalities for general-purpose programming, including data structures, file I/O, networking and concurrency.
%
Platform-specific code can be written using conditional compilation directives, similarly to C-style preprocessor macros.

Concerning interoperability, Haxe allows to interface with target-specific syntax and APIs creating, like all presented languages, typed facades.
%
However, unlike Scala and Kotlin, these facades are not automatically generated for most of the platforms, requiring manual effort to create them.
%
Moreover, for integrating with native libraries, no unified mechanism exists.
%
Instead, each target platform needs to rely on its own build tool to link with external libraries, which may complicate the build process when targeting many platforms.

Although not as popular as other languages, Haxe has found a niche in video game development and, thanks to its broad platform coverage, is a viable option for projects prioritizing maximum platform coverage over advanced language abstractions or reliance on specific ecosystems.

\subsubsection{Flutter/Dart}

Dart\footnote{\url{https://dart.dev}} represents another notable approach to cross-platform development.

Dart, developed by Google, is a statically-typed, object-oriented language best known for powering the Flutter framework, which enables cross-platform application development for mobile, desktop, and web from a single codebase.
%
It targets native platforms (including Android and Apple devices) via Ahead-of-Time (AOT) compilation and web platforms through transpilation to JavaScript and WebAssembly.

Interoperability in Dart is achieved through different mechanisms depending on the target platform.
%
On native, Dart both provides an asynchronous message-passing mechanism for communication with platform-specific code, and a Foreign Function Interface (FFI) enabling more direct and efficient invocation of native code from Dart.
%
On web platforms, interoperability is provided through JavaScript interoperability mechanisms allowing Dart code to call JavaScript functions and vice versa.

These characteristics make Flutter and Dart primarily well-suited for UI-centric and client-side applications, especially in mobile applications, where the framework has reached significant maturity and adoption.

\vspace{1.5em}

\Cref{tab:comprehensive-comparison} presents a comparison of the analyzed cross-platform languages and their main characteristics, including their maturity levels in terms of ecosystem and toolchain.

\begin{table}[htbp]
    \centering
    \scriptsize % Smaller font for dense tables
    \setlength{\tabcolsep}{4pt} % Reduce horizontal padding
    \renewcommand{\arraystretch}{1.15} % Slightly tighter vertical spacing

    \caption{Cross-platform languages comparison}
    \label{tab:comprehensive-comparison}
    \vspace{0.4em}

    \makebox[\textwidth][c]{%
        \begin{tabularx}{\textwidth}{
            @{}
            >{\raggedright\arraybackslash}p{1.3cm}  % Language
            >{\raggedright\arraybackslash}p{1.7cm}  % Paradigm(s)
            >{\raggedright\arraybackslash}X         % Supported Environments
            >{\raggedright\arraybackslash}p{1.8cm}  % Approach
            >{\raggedright\arraybackslash}X         % Language Interoperability
            >{\raggedright\arraybackslash}X         % Maturity
            >{\raggedright\arraybackslash}p{1.8cm}  % Toolchain
            @{}
        }
            \toprule
            \textbf{Language} &
            \textbf{Paradigm(s)} &
            \textbf{Supported Environments} &
            \textbf{Primary Approach} &
            \textbf{Language interoperability} &
            \textbf{Ecosystem maturity} &
            \textbf{Toolchain maturity} \\
            \midrule

            Scala &
                OOP + FP &
                JVM$^{\circ}$, \newline JS, \newline WASM$^{\dagger}$, \newline Native &
                Cross-compilation &
                Java, \newline C and C++$^{\leadsto}$, \newline JS and TS$^{\leadsto}$ &
                JS: Mature, Native: Growing & 
                JS: Mature, Native: Developing \\

            \addlinespace[5pt]

            Kotlin MP &
                OOP+FP &
                JVM$^{\circ}$, \newline JS, WASM$^{\dagger}$, \newline Native, \newline Mobile (Android, Apple) &
                Cross-compilation &
                Java, \newline C and C++$^{\leadsto}$, \newline Obj-C/Swift, \newline JS and TS$^{\leadsto}$ &
                Mature &
                Mature \\

            \addlinespace[5pt]

            Gleam &
                FP &
                BEAM$^{\circ}$, \newline JS &
                Transpilation &
                Erlang, \newline JS and TS$^{\leadsto}$ &
                Emerging &
                Developing \\

            \addlinespace[5pt]
            
            Haxe &
                OOP &
                JS, \newline Native, \newline .NET, \newline JVM, \newline PHP, \newline Python, \newline Lua &
                Hybrid &
                C++, \newline C\#, \newline Java, \newline PHP, \newline Python, \newline Lua, \newline JS and TS$^{\leadsto}$ &
                Growing &
                Developing \\

            \addlinespace[5pt]

            Flutter / Dart &
                OOP &
                Native, \newline Mobile (Android, Apple), \newline JS, \newline WASM &
                Cross-compilation &
                C and C++$^{\leadsto}$, \newline Obj-C/Swift, \newline JS and TS$^{\leadsto}$ &
                Established &
                Production-Grade \\

            \bottomrule
        \end{tabularx}%
    }

    \vspace{0.4em}
    \footnotesize
    \begin{tabular}{p{0.4\textwidth} p{0.6\textwidth}}
        \raggedright
        $^{\circ}$ Primary target platform \\
        $^{\dagger}$ Experimental feature \\
        $^{\leadsto}$ Indirectly, via a "companion" language

        &

        \raggedright
        \textbf{Ecosystem maturity:} \textit{Emerging} (limited libraries and adoption), \textit{Growing} (expanding libraries, active development, limited community support), \textit{Mature} (rich ecosystem), \textit{Established} (extensive packages, widely used in industry) \\
        \textbf{Toolchain maturity:} \textit{Experimental} (minimal tooling, unstable), \textit{Developing} (basic tools, some instability), \textit{Mature} (production-ready), \textit{Production-Grade} (robust, widely adopted in production)
    \end{tabular}
\end{table}
