@startuml socket-distribution

skinparam interface<<trait>> {
  BackgroundColor lightblue
  BorderColor blue
  StereotypeFontColor blue
}

package "core" {
    interface NetworkManager << (T,#b2a7e0) trait >> {
        + type DeviceId
        + send(message: Export[DeviceId])
        + receive(): Import[DeviceId]
    }
}

package "distributed" {
    package "shared" {
        ' object InetTypes << object >> {
        '     + type IPv4
        '     + type IPv6
        '     + type Address
        '     + type Port
        '     + type Hostname
        '     + type Endpoint
        ' }

        interface ConnectionOrientedNetworking << (T,#b2a7e0) trait >> {
            + type MessageIn
            + type MessageOut
            ---
            + out(endpoint: Endpoint): Future[Connection]
            ---
            + in(port: Port)(\n    onReceive: MessageIn => Unit\n): Future[ListenerRef]
        }
        ConnectionOrientedNetworking +-- Connection
        ConnectionOrientedNetworking +-right-- ListenerRef

        interface ConnectionState << (T,#b2a7e0) trait >> {
            + isOpen: Boolean
        }

        interface Connection << (T,#b2a7e0) trait >> extends ConnectionState {
            + send(message: MessageOut): Future[Unit]
            + close()
        }

        class ListenerRef {
            + listener: Listener
            + accept: Future[Unit]
        }
        ListenerRef *- Listener

        interface Listener << (T,#b2a7e0) trait >> extends ConnectionState {
            + boundPort: Port
            + close()
        }

        interface ConnectionOrientedTemplate << (T,#b2a7e0) trait >> extends ConnectionOrientedNetworking {
            + type MessageIn : BinaryDecodable
            + type MessageOut : BinaryEncodable
        }
        note bottom of ConnectionOrientedTemplate
            Template class 
            implementing common 
            platform-agnostic logic
        end note

        interface NeighborhoodResolver << (T,#b2a7e0) trait >> {
            + type Neighborhood[DeviceId] = Set[DeviceId]
            + neighborhood: Neighborhood[DeviceId]
        }

        interface ConnectionOrientedNetworkManager<ID> << (T,#b2a7e0) trait >> {
            + override type DeviceId = ID
            + type Envelope = (DeviceId, ValueTree)
            + override type MessageIn = Envelope
            + override type MessageOut = Envelope
        }
        ConnectionOrientedNetworkManager *-right-> ConnectionOrientedNetworking : mixed in
        ConnectionOrientedNetworkManager *-left-> NeighborhoodResolver : mixed in
        core.NetworkManager <|--- ConnectionOrientedNetworkManager

        object SocketNetworkManager <<object>> {
            + withFixedNeighborhood[DeviceId](\n    deviceId: DeviceId,\n    port: Port,\n    neighbors: Map[DeviceId, Endpoint]\n)
        }
        note bottom of SocketNetworkManager
            Socket-based network
            manager factories
        end note
        SocketNetworkManager .up.> ConnectionOrientedNetworkManager
    }

    package "jvm-native" {
        interface SocketNetworking << (T,#b2a7e0) trait >>
        SocketNetworking --up-|> distributed.shared.ConnectionOrientedTemplate
        note bottom of SocketNetworking
            JVM-native socket-based implementation
        end note
    }

    package "js" {
        interface SocketNetworking << (T,#b2a7e0) trait >> 
        SocketNetworking --up-|> distributed.shared.ConnectionOrientedTemplate
        note bottom of SocketNetworking
            Node.js socket-based implementation
        end note
    }

}

@enduml